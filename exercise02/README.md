# Exercise Sheet 2

From here on, `Makefiles` with `all` (default) and `clean` rules are required. Your source code must compile by running make in the corresponding folder.

## Task 1

In this task you will familiarize yourself with the build system `make`.

### Using make for building C code

In the directory [task1](task1/) we provide some source code.
This code is already complete, you should not modify it.
The task here is to create a Makefile in this directory which can be used to compile the provided code.

Your Makefile shall meet the following criteria:

- There must be a rule called `all`, which builds the code.
- When running just `make` in the `task1` directory, the `all` rule should be executed.
- All calls to the C compiler should use the flags `-std=c11 -Wall -Wextra`.
- There must be a rule called `clean`, which removes all artifacts generated by the compiler.
- The C files should first be compiled to intermediary object files (`greet.o` and `main.o`),
  which are then combined into the final executable in a separate rule.

If everything works correctly, you should be able to call `make` in the directory `task1`,
which generates the executable `main`, and some object files.
Running this executable should print `Hello World.`.
When running `make clean`, the executable and the object files should be deleted.

Comprehensive documentation of GNU make can be found [online](https://www.gnu.org/software/make/manual/html_node/index.html).

### Using make to automate other tasks

`make` is mainly used for building code, but it can also be helpful for many other tasks.
For each rule, the recipe which is executed can run arbitrary shell commands.

The idea of this part of the task is automating part of the homework submission process:

1. Cleaning up build artifacts from the different tasks.
2. Building the zip archive which you can then submit.

For all tasks in which you work with C code there should be a Makefile with a `clean` rule in the corresponding directory,
as specified in the previous part of the task.
Create a Makefile in the directory which contains the directories `task1`, `task2`, and `task3`.
This Makefile should also have a `clean` rule, which calls `make clean` in the directories of the three different tasks
(you do not have to do it for tasks 2 and 3 if you do not submit them).

Additionally, define a rule called `zip` which first deletes the archive if it already exists
and then zips the content of the directory in which this Makefile is stored.
The generated zip archive should only contain the files we want in the submission,
so there should be no extra files in this directory or any child directories.
To ensure that no build artifacts are included in the archive,
write the `zip` rule in such a way that it first calls the `clean` rule described in the previous paragraph.

_Hint_: For information on how `make` should be called in a Makefile, check the [GNU make documentation](https://www.gnu.org/software/make/manual/html_node/Recursion.html).

_Hint_: You can recursively zip a directory with `zip -r ../archive.zip .`
This will put everything contained in the current directory into the archive, which is stored in the parent directory.

Try to write your Makefiles in a way which allows you to continue using them for future homework with minimal modification.

## Task 2

Create a program that registers handler(s) for the signals `SIGINT`, `SIGSTOP`, `SIGCONT`, and `SIGKILL` using `sigaction` (you must **not** use `signal`).
When a signal is received, it outputs a message indicating which signal was received.
After registering the signal handler(s), call `usleep` in a loop to prevent the process from exiting.

Have a look at the following man pages `sigaction(2)`, `signal(7)`, and `signal-safety(7)`.
Read also [SIG30-C](https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers) and [SIG31-C](https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers).

You can use the shell commands `ps` and `pgrep` to find the process ID (PID) of a process.
`kill` can be used to send a signal to a process.

What difference do you notice between `SIGINT` and `SIGKILL`?

What happens when you press `CTRL + c` while the program is running?

What can the signals `SIGSTOP` and `SIGCONT` be used for?

_Note:_ In order to use `sigaction` and `usleep` you have to define `_POSIX_C_SOURCE` and `_BSD_SOURCE` feature test macros.
This can be done by adding the compile flag `-D_POSIX_C_SOURCE -D_BSD_SOURCE`.
See the `feature_test_macros(7)` man page for more information.
On modern systems the `_BSD_SOURCE` feature test macro has been deprecated and replaced by `_DEFAULT_SOURCE`, however this is not available on `zid-gpl`.
You may ignore the deprecation warning that is emitted when using `_BSD_SOURCE`, however your program should not generate any other warnings.

## Task 3

Write a program which creates `N` child processes using `fork(2)`, each computing an estimate of the number PI using a [Monte Carlo simulation](https://de.wikipedia.org/wiki/Monte-Carlo-Simulation) with `S` random samples.
Both `N` and `S` can be specified on the command-line.

The parent first **creates all children**, then **waits** until they have exited, and finally prints `Done.`. The parent process **must not** wait for any children **until all of them** are created.

Every child:

- computes an estimate of PI using `S` random samples; then
- prints a message of the form `Child <i> PID = <PID>. mc_pi(<S>) = <mc_pi(S)>. Elapsed time = <t>.` where
  `<i>` is the child number,
  `<PID>` is the child's process id,
  `<S>` is the random samples parameter,
  `<mc_pi(S)>` is the calculation result,
  and `<t>` is the elapsed time since the parent was started.

Make sure to only once measure the starting time of the parent process.

_Hint:_ You can use `clock_gettime()` (have a look at the man page `clock_gettime(2)`) to measure wall time. For this to work you have to define `-D_POSIX_C_SOURCE=199309L` feature test macros (see Task 2).

Use the following implementation for the Monte Carlo simulation:

```c
double mc_pi(int64_t S) {
    int64_t in_count = 0;
    for(int64_t i = 0; i < S; ++i) {
        const double x = rand() / (double)RAND_MAX;
        const double y = rand() / (double)RAND_MAX;
        if(x*x + y*y <= 1.0) {
            in_count++;
        }
    }
    return 4 * in_count / (double)S;
}
```

_Hint_: A parent process can wait for its children using `wait(2)` or `waitpid(2)`.

Example output:

```sh
$ ./task1 3 100000000
Child  0 PID = 1285. mc_pi(100000000) = 3.141683. Elapsed time = 1.716899 (s)
Child  1 PID = 1286. mc_pi(100000000) = 3.141518. Elapsed time = 1.787224 (s)
Child  2 PID = 1287. mc_pi(100000000) = 3.141772. Elapsed time = 1.936618 (s)
Done.
```

Experiment with different values for `N` and `S`.
Analyze the obtained output.
Is the order of the messages consistent?
Can the order of these messages be predicted?
What does it depend on?

Notice that the function `mc_pi` uses `rand(3)` to repeatedly generate pseudo-random numbers.
By default this function returns the same sequence of numbers every time.
To get different estimates from each process, _seed_ the random number generator using `srand(getpid())`.
Does it matter whether you do this before or after the call to `fork()`?
Explain your answer.

--------------

Submit your solution as a zip archive via OLAT, structured as follows, where csXXXXXX is your UIBK login name. Your zip archive **must not** contain binaries.

```text
exc02_csXXXXXX.zip
├── Makefile             # second Makefile from task1
├── group.txt            # optional
├── task1/
│   ├── Makefile
│   ├── main.c
│   ├── greet.c
│   └── greet.h
├── task2/
│   ├── Makefile
│   ├── signal_handler.c
│   └── task_2_summary.txt
└── task3/
    ├── Makefile
    ├── task3.c
    └── task_3_summary.txt
```

Requirements

- [ ] Auto-format all source files
- [ ] Check your submission on ZID-GPL
- [ ] Check your file structure
- [ ] Submit zip
- [ ] Mark solved exercises in OLAT
- [ ] Any implementation MUST NOT produce any additional output
- [ ] If you work in a group, create a `group.txt` file according to the format specified below.

If you worked in a group, the `group.txt` file must be present
and have one line per student which contains the matriculation number
in the beginning, followed by a space and the student's name.
For example, if the group consists of Jane Doe,
who has matriculation number 12345678,
and Max Mustermann, who has matriculation number 87654321,
the `group.txt` file should look like this:

```text
12345678 Jane Doe
87654321 Max Mustermann
```
